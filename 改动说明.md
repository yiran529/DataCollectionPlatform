## 所有改动说明

### **1. 诊断脚本（用于问题排查）**

#### 📄 host_computer/diagnose_crash.py
- **目的**：逐步测试各个模块，找出导致 "Illegal instruction" 崩溃的原因
- **测试内容**：Python基础 → NumPy → OpenCV → YAML → h5py → sync_data_collector → 摄像头初始化
- **用途**：当程序崩溃时，逐步运行诊断找出问题所在

#### 📄 host_computer/diagnose_jetson.py
- **目的**：Jetson Xavier 专用诊断工具
- **功能**：使用 subprocess 测试 NumPy/OpenCV 导入（避免直接导入导致进程崩溃）
- **输出**：判断是否能使用系统包，还是需要环境变量修复

#### 📄 host_computer/detect_cameras.py
- **目的**：自动检测 Jetson 上的摄像头设备及支持的格式
- **检测方法**：
  - 扫描 `/dev/video*` 设备文件
  - 逐个尝试用 OpenCV 打开
  - 显示每个摄像头的分辨率和 FPS
- **输出**：自动建议需要修改的 config.yaml 配置

#### 📄 host_computer/detect_stereo_formats.py
- **目的**：检测 Stereo 摄像头支持的具体格式和分辨率
- **功能**：逐个尝试不同的分辨率/FPS 组合，找出可用配置

#### 📄 host_computer/test_cameras.py
- **目的**：测试摄像头能否正常采集数据（不使用 GStreamer）
- **验证内容**：Mono 和 Stereo 摄像头独立采集测试

#### 📄 host_computer/find_data.py
- **目的**：查找采集的数据文件和诊断数据保存问题
- **功能**：检查所有可能的数据目录，列出已保存的数据文件

---

### **2. 配置文件修改**

#### 📝 host_computer/config.yaml

**改动1：设备号和分辨率更新**

改动前：
```yaml
left_hand:
  mono:
    device: 10        # ❌ 不存在的设备
    fps: 30
  stereo:
    device: 8         # ❌ 不存在的设备
    fps: 30

right_hand:
  mono:
    device: 6         # ❌ 不存在的设备
    fps: 30
  stereo:
    device: 4         # ❌ 不存在的设备
    fps: 30
```

改动后：
```yaml
left_hand:
  mono:
    device: 1         # ✅ 真实设备：1600x1300 @ 5fps
    width: 1600
    height: 1300
    fps: 5
  stereo:
    device: 0         # ✅ 真实设备：3840x1080 @ 1fps（硬件固定格式）
    width: 3840
    height: 1080
    fps: 1

right_hand:
  mono:
    device: 1         # ✅ 真实设备
    width: 1600
    height: 1300
    fps: 5
  stereo:
    device: 0         # ✅ 真实设备
    width: 3840
    height: 1080
    fps: 1
```

**原因**：
- 原始设备号（4,6,8,10）在你的 Jetson Xavier 上不存在
- 诊断脚本自动检测到真实摄像头：`/dev/video0` 和 `/dev/video1`
- Stereo 摄像头硬件只支持 3840x1080 @ 1fps（不可改变）
- Mono 摄像头支持 1600x1300 @ 5fps

---

### **3. 摄像头驱动代码修改**

#### 📝 data_coll/sync_data_collector.py

**改动1：禁用 GStreamer 硬件加速（open() 方法）**

改动前：
```python
def open(self) -> bool:
    # 检测是否为 Jetson 平台，优先使用 GStreamer 以获得更好的性能
    use_gstreamer = self._is_jetson_platform()  # ❌ 自动启用
    
    if use_gstreamer:
        # GStreamer JPEG 硬件解码管道
        gst_pipeline = (...)
        self.cap = cv2.VideoCapture(gst_pipeline, cv2.CAP_GSTREAMER)
```

改动后：
```python
def open(self) -> bool:
    # 注意：GStreamer 在某些 Jetson 配置下可能不稳定，默认禁用
    # 如需启用 GStreamer，设置环境变量: export USE_GSTREAMER=1
    use_gstreamer = os.environ.get('USE_GSTREAMER', '0') == '1' and self._is_jetson_platform()
    
    if use_gstreamer:
        # GStreamer 管道
        ...
    else:
        # 使用标准 V4L2（更稳定）
        self.cap = cv2.VideoCapture(self.device_id)
        print(f"[{self.name}] 使用标准 V4L2 模式")
```

**改动原因**：
- GStreamer 要求摄像头支持 JPEG 硬件编码，但你的摄像头不支持
- 导致错误：`Internal data stream error`
- 标准 V4L2 驱动更稳定，自动格式协商

**改动2：优化设备初始化（open() 方法）**

改动前：
```python
if not self.cap.isOpened():
    print(f"[{self.name}] 无法打开设备 {self.device_id}")
    return False

# 设置参数
self.cap.set(...)

# 预热（10次读取）
for _ in range(10):
    self.cap.read()
```

改动后：
```python
if not self.cap.isOpened():
    print(f"[{self.name}] ❌ 无法打开设备 /dev/video{self.device_id}")
    return False

print(f"[{self.name}] ✓ 设备已打开，设置参数...")

# 设置参数（增加异常处理）
try:
    self.cap.set(cv2.CAP_PROP_FOURCC, cv2.VideoWriter_fourcc(*'MJPG'))
    self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, self.width)
    ...
except Exception as e:
    print(f"[{self.name}] ⚠️ 参数设置异常: {e}")
    return False

# 快速超时预热（3秒）
timeout = time.time() + 3.0
for i in range(20):
    if time.time() > timeout:
        break
    ret, frame = self.cap.read()
    if ret:
        read_count += 1
        if read_count >= 1:  # 只要 1 帧就够
            break
```

**改动原因**：
- Jetson Xavier 的 USB 初始化较慢（需要等待）
- 预热完全成功不是必须的（只要能读到 1 帧就可以）
- 快速超时避免程序卡死

---

#### 📝 host_computer/dual_hand_collector.py

**改动1：修改摄像头打开顺序**

改动前：
```python
# 先打开 Mono，再打开 Stereo
self.mono = CameraReader(...)
self.stereo = CameraReader(...)

if not self.mono.open() or not self.stereo.open():
    print(f"[{self.hand_name}] ❌ 相机初始化失败")
```

改动后：
```python
# 创建对象（先 Stereo，后 Mono）
self.stereo = CameraReader(...)
self.mono = CameraReader(...)

# 重要：先打开 Stereo，再打开 Mono
# 这样可以避免 USB 竞争条件导致的预热超时
print(f"[{self.hand_name}] 打开 Stereo 摄像头...")
if not self.stereo.open():
    print(f"[{self.hand_name}] ❌ Stereo 摄像头初始化失败")
    self._running = False
    return

print(f"[{self.hand_name}] 打开 Mono 摄像头...")
if not self.mono.open():
    print(f"[{self.hand_name}] ❌ Mono 摄像头初始化失败")
    self.stereo.cap.release()
```

**改动原因**：
- 两个 USB 摄像头竞争有限的 USB 带宽
- 高分辨率 Stereo (3840x1080) 需要更多带宽
- 先打开 Stereo 能优先获得资源，避免冲突

**改动2：放宽时间戳同步容限**

改动前：
```python
def stop_recording(self) -> List[HandFrame]:
    ...
    # 使用 50ms 的时间差容限
    aligned = self._align_data_batch(stereo_data, mono_data, encoder_data)
    # 默认参数：max_time_diff_ms: float = 50.0
```

改动后：
```python
def stop_recording(self) -> List[HandFrame]:
    ...
    # 使用 200ms 的时间差容限（适应 1fps 和 5fps 的混合采集）
    aligned = self._align_data_batch(stereo_data, mono_data, encoder_data, max_time_diff_ms=200.0)
```

**改动原因**：
- Stereo 1fps，Mono 5fps，帧率差异大
- 原来 50ms 的容限太严格，导致无法对齐（对齐后: 0 帧）
- 200ms 容限允许不同帧率的数据成功对齐
- 结果：数据能成功保存而不是丢失

---

### **4. 启动脚本**

#### 📝 host_computer/run_collector.sh
- **目的**：简化启动命令，自动处理环境变量和配置文件路径
- **功能**：
  - 自动禁用 GStreamer
  - 自动设置正确的配置文件路径
  - 支持两种模式：`visualize`（默认）和 `record`
- **使用方法**：
  ```bash
  bash ./host_computer/run_collector.sh right record      # 录制模式
  bash ./host_computer/run_collector.sh right visualize   # 可视化模式
  ```

---

## 核心问题和解决方案总结

| 问题 | 原因 | 解决方案 |
|------|------|--------|
| **NumPy/OpenCV 崩溃** | CPU 指令集不兼容 (AVX2) | 使用系统包或禁用 SIMD 优化 |
| **摄像头无法打开** | 设备号错误 | 自动检测 `/dev/video0`, `/dev/video1` |
| **GStreamer 错误** | 摄像头不支持 JPEG 硬件编码 | 改用标准 V4L2 驱动 |
| **Stereo 初始化失败** | USB 带宽竞争 | 改变打开顺序（先 Stereo 后 Mono） |
| **Mono 预热超时** | Jetson USB 初始化慢 | 快速超时策略 + 设备预热完全可选 |
| **数据保存失败** | 时间戳同步容限太严格 | 放宽容限从 50ms → 200ms |

---

## 改动效果对比

| 指标 | 改动前 | 改动后 |
|------|--------|--------|
| **程序能否启动** | ❌ 频繁崩溃 | ✅ 正常启动 |
| **摄像头初始化** | ❌ 无法打开设备 | ✅ 两个摄像头成功打开 |
| **数据采集** | ❌ 0 帧对齐，无数据保存 | ✅ 成功采集和保存数据 |
| **稳定性** | ❌ GStreamer 错误 | ✅ 标准 V4L2 驱动稳定 |
| **诊断能力** | ❌ 无法定位问题 | ✅ 多个诊断脚本逐步排查 |

---

## 使用改动后的程序

### 录制模式（推荐用于数据采集）
```bash
cd ~/DataCollectionPlatform
bash ./host_computer/run_collector.sh right record
```

**操作步骤：**
1. 按回车键开始录制
2. 执行手部动作
3. 再按回车键停止录制
4. 数据自动保存为 HDF5 文件，位置：`~/DataCollectionPlatform/data/YYYYMMDD_HHMMSS_right_hand_data.h5`

### 可视化模式（预览摄像头）
```bash
bash ./host_computer/run_collector.sh right visualize
```

按 `q` 键退出。

### 手动运行（如需自定义参数）
```bash
export USE_GSTREAMER=0
python3 ./host_computer/single_hand_collector.py \
    --config ./host_computer/config.yaml \
    --hand right \
    --record
```

---

## 数据文件查询

```bash
# 列出所有采集的数据文件
ls -lh ~/DataCollectionPlatform/data/

# 查看最新的采集文件
ls -lht ~/DataCollectionPlatform/data/ | head -1
```

数据文件名格式：`YYYYMMDD_HHMMSS_hand_name_data.h5`

---

## 技术细节（硬件限制）

### 摄像头规格
- **Stereo 摄像头** (`/dev/video0`)：
  - 固定输出：3840x1080 @ 1fps（硬件约束，无法改变）
  - 用于立体视觉
  
- **Mono 摄像头** (`/dev/video1`)：
  - 分辨率：1600x1300
  - 帧率：5fps（支持 5fps，不支持 1fps）

### 同步策略
- 时间戳对齐容限：**200ms**（宽松策略）
- 允许 Stereo (1fps) 和 Mono (5fps) 混合采集
- 编码器可选（未连接时使用默认值 0）
